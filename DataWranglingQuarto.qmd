---
title: "Data Wrangling BIOE 276 Assignment 1"
author: "Ward, A"
format: 
  pdf: default
editor: visual
---

# Activity 6: Data wrangling 1: rows and columns

## 1.1 Introducing tidyverse and the pipeline

Begin by loading packages

```{r}
## Load packages from library
library("tidyverse")
library(here)
```

Starting with a vector and stringing multiple functions with the pipeline:

```{r}
#| output: true

#Create vector
fruits <- c("apple", "apple", "orange", "orange", "banana")

#Find unique values
unique(fruits)
```

If I am wanting to apply the length function to this vector, I can either:

```{r}
#| output: true

# 1) Nest the unique function within the length function
length(unique(fruits))
```

```{r}
#| output: true

# 2) Create intermediate data objects
unique.fruits <- unique(fruits)
length(unique.fruits)
```

OR, I can use the pipeline here:

```{r}
#| output: true

#This :
fruits %>% unique()

#is equivalent to this:
unique(fruits)
```

And you can pipe together multiple:

```{r}
#| output: true

# Piping!
fruits %>% unique() %>% length()

#Can be spread across multiple lines
fruits %>% 
  unique() %>% 
  length()

```

## 1.2 Import data, apply the pipeline

Import data:

```{r}
# Import the data
cereal <- read_csv(here("cereal.csv"))

# Take a look at the first six rows
head(cereal)
```

We can use the pipeline to extract many things at once:

```{r}
#| output: true

# Start with the cereal dataframe
cereal %>%
  # This line extracts the column names from the dataframe input and creates a vector
  colnames() %>% 
  # This line calculates the "length" (the number) of those names from the vector input
  length()
```

## 1.3 `select()` columns

Selecting columns from cereal:

```{r}
cereal %>% 
  select(name, calories, fiber)
```

```{r}
#Storing as new object
cereal_fiber <- cereal %>% 
  select(name, calories, fiber)

```

```{r}
#Excluding certain columns
cereal %>% 
  select(-name, -mfr)
```

### Q1.1: Create a new dataframe with `select()`

```{r}
#| output: true

#Creating a new df 
cereal_sugar <- cereal %>% 
  select(name, mfr, sugars) #selecting name, manufacturer, and sugar per serving
```

## 1.4 `rename()` columns

Learning to rename columns with rename:

```{r}
#| output: true
cereal_sugar %>% 
  # Rename the mfr column to a more informative manufacturer
  rename(manufacturer = mfr)

#Rename multiple columns
cereal_sugar %>% 
  rename(manufacturer = mfr,
         cereal_name = name)
```

## 1.5 `relocate()` columns

Relocate where columns are in the data frame:

```{r}
#| output: true
#Moving manufacturer before cereal name
cereal_sugar %>% 
  relocate(mfr, .before = name)

```

## 1.6. `filter()` for certain rows

Filter gives certain rows based on specified conditions:

```{r}
#| output: true
#Filtering for those with >12 grams of sugar
cereal_sugar %>% 
  filter(sugars > 12)
```

```{r}
#filtering for kellogs cereals
cereal_sugar %>% 
  filter(mfr == "Kelloggs")
```

### Q1.2 Filter for Kelloggs AND sugars \> 12

Filter the dataframe to return rows where the manufacturer is Kelloggs AND the sugars are greater than 12, all within the same filter function:

```{r}
#| output: true
#Filtering for both >12 and for Kellogs
cereal_sugar %>% 
  filter(mfr == "Kelloggs" & sugars > 12)
```

### Q1.3 Select and then filter using pipelines

Now we will look at how the %\>% operator can be particularly helpful. Say we want to select certain columns and THEN filter that data.

Using what you learned about stringing together functions in sections 1.1 and 1.2:

1.  Take the cereal dataframe and select the name, fat, and potassium columns

2.  Then filter that output to return rows where potassium is less than 30

You should string together two functions with two pipelines here.

```{r}
#| output: true
#Filtering cereal df
cereal_K <- cereal %>% 
  select(name, fat, potass) %>% 
  filter(potass < 30)

head(cereal_K)
```

### Q1.4 Yet another select/filter challenge

```{r}
#| output: true
#Filtering cereal df
cereal_nutrition <- cereal %>% 
  filter(calories> 120) %>% 
  select(name, fiber, fat, sodium)
 

head(cereal_nutrition)
```

## 1.7 `arrange()` your rows by value

Using the arrange function to sort our dataframe. First numerically:

```{r}
#| output: true
cereal %>% 
  arrange(calories)
```

```{r}
#| output: true
cereal %>% 
  # The desc() reverses the order, making it highest to lowest
  arrange(desc(calories))
```

Now alphabetically:

```{r}
#| output: true
cereal %>% 
  arrange(mfr, calories)
```

## 1.8 `mutate()` columns: add or edit them

Learning more about the mutate function by mutating the sugars column:

```{r}
#| output: true
#Create new df
cereal_carbs <- cereal %>% 
  # Select just the name, carbs, and sugars columns, and store it as a new data object called cereal_carbs
  select(name, carbo, sugars)

#New sugars column
cereal_carbs %>% 
  # in this case, the new sugars_total column is going to be 2 times the sugars column
  mutate(sugars_total = sugars*2)
```

```{r}
#| output: true
#Use existing column name 
cereal_carbs %>% 
  mutate(sugars = sugars*2)
```

```{r}
#| output: true
# Check that the original cereal_carbs data is unaltered
cereal_carbs
```

New column equal to sugars + milk

```{r}
cereal_carbs %>% 
  mutate(sugars_with_milk = sugars + 5)
```

If we want to add multtiple at once we can either

```{r}
#1 Usse two mutate functions in a row
cereal_carbs %>% 
  mutate(total_carbs = carbo + sugars) %>% 
  mutate(sugars_with_milk = sugars + 5)
```

```{r}
#2 Or separate the two equations within the one mutate function with commas
cereal_carbs %>% 
  mutate(total_carbs = carbo + sugars,
         sugars_with_milk = sugars + 5)
```

# 2. Bison!

Uploading packages

```{r}
library(lterdatasampler)
```

```{r}
#Naming data
bison <- (knz_bison)

#Summary df
summary(bison)
```

## Q2.1 Add new columns

```{r}
#Age and weight of bison col
bison_age <- bison %>% 
  mutate(age = rec_year - animal_yob,
         animal_weight_kg = animal_weight * 0.454)
```

## Q2.2 Write a research question

Has age structure changed over time in this bison population and is there any difference in shift in males vs females?

## Q2.3 Make a graph and interpret it to answer your question

```{r}
#Combine year month and day of record
bison_age <- bison_age %>% 
  mutate(date = make_date(rec_year, rec_month, rec_day))
  
#get summary data of ages in time
summary_stat_age <- bison_age %>% 
  group_by(rec_year, animal_sex) %>% 
  summarise(
    mean_age = mean(age, na.rm = TRUE),
    median_age = median(age, na.rm = TRUE),
    .groups = "drop"
  ) 
```

```{r}
ggplot(summary_stat_age, aes(x = rec_year, y = mean_age, color = animal_sex)) +
  geom_line(linewidth = 1.2) +
  scale_color_manual(values = c("F" = "#8AF1FE", "M" = "#301934")) +
  labs(x = "Year",
       y = "Mean Age",
       color = "Sex") +
  theme_classic()

ggplot(summary_stat_age, aes(x = rec_year, y = median_age, color = animal_sex)) +
  geom_line(linewidth = 1.2) +
  scale_color_manual(values = c("F" = "#8AF1FE", "M" = "#301934")) +
  labs(x = "Year",
       y = "Median Age",
       color = "Sex") +
  theme_classic()
```

1\) This graph shows that the average age of males versus females is quite different. Females tend to live, on average 2-3 years longer than males. However, this graph also shows that variability in age has also seemingly decreased over time, where there used to be more variation in average age from year to year and now there seems to be less variability both within males and females. This stability within average age might suggest more stability within the population itself or a movement toward equilibrium.

2\) I would be more curious about this population and the various pressures it may be facing. Is this population becoming more stable as a healthy, growing population? Or is there a movement toward a stable age because of other selective causes?

## Q2.4 Export the graph
